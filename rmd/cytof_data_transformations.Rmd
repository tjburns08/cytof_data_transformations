---
title: "Data transformations"
output: html_document
date: March 31, 2022 - June 29, 2022
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The purpose of this markdown is to explore the topic of data transformations for CyTOF data. We will look at how the asinh and logarithmic data transformations are related to each other. Then, we will examine t-SNE maps of untransformed versus transformed data. 

# Import data

The dataset we're going to use is a PBMC dataset generated by Stanford's HIMC in 2016, found [here](https://flowrepository.org/experiments/1363/download_ziped_files).

```{r import_data}
library(flowCore)
library(tidyverse)
library(here)

setwd(here::here("data", "himc_dataset"))
ff <- flowCore::read.FCS("081216-Mike-HIMC ctrls-001_01_normalized.fcs",
                            transformation=FALSE, 
                            truncate_max_range=FALSE)
ff
```

We've read in the fcs and now we have a flow frame object. You can see that there are 841000 cells. We're not going to need nearly that many to do the dimension reduction anlaysis that we're going to get to. So we're going to subsample the flow frame to 30,000 cells. How do you do that? While the flow frame object is complex, it turns out you can treat a flow frame like a matrix, in that you can pull out "rows" as shown below for 10 of them. For completeness, I show a subsampling of columns, and the use of "dim" to get at the dimensions of the matrix that the flow frame object contains.

```{r subset_example}
ff[1:10,]
ff[,1:10]

dim(ff)
```

Given this notation, a random subsample to a smaller number is straightforward. We're going to run it below. Part of the rationale behind this is simply that it makes it easier to visualize the plots. 

```{r subset}
n_cells <- 5000
ff <- ff[sample(x = nrow(ff), size = n_cells, replace = FALSE),]
ff
```

You can see that now we're dealing with a flow frame that has 30000 cells rather than the much larger orignal number. Now we have to pull out the matrix in the flow frame, as that's where we're going to do our work. Luckily, there's a command called exprs() that does this. Let's look at what happens when we run it. 

In most files, the column names of the matrix are actually the isotope values. One can easily change these by going into the "name" and "desc" parameter, which are in the proper order row-wise as the expression matrix is column-wise.

```{r get_matrix}
cells <- exprs(ff) %>% as_tibble()
cells
```
```{r change_param_names}
ff@parameters@data %>% as_tibble()

params <- ff@parameters@data$desc 
colnames(cells) <- params

# tidy
cells <- cells[!is.na(names(cells))]
```

# Data transformation

## Asinh with different scale arguments

From here, we do a data transformation. For CyTOF, we typically do an asinh transform of the given channel value divided by 5 (call a scale argument of 5). The tranform is log-like, but is ok for negative numbers as well. But let's look at different "scale arguments" to see if 5 is special. 

```{r transform_example}

biaxial <- dplyr::select(cells, "166Er_CD33", "150Nd_CD3")

MakePlot <- function(dat) {
    qplot(dat[[1]], dat[[2]]) + labs(x = names(dat)[1], y = names(dat)[2]) 
}

scale_arguments <- c(-1, 1, 5, 10, 50, 100, 500)
plot_list <- lapply(scale_arguments, function(i) {
    if(i == -1) {
        result <- MakePlot(biaxial) + ggtitle("untransformed")
    } else {
        result <- MakePlot(asinh(biaxial/i)) + ggtitle(paste0("asinh(x/", i, ")"))
    }
    return(result)
})

n_col <- floor(sqrt(length(plot_list)))

cowplot::plot_grid(plotlist = plot_list[1:4], align = "v", nrow = 2)
cowplot::plot_grid(plotlist = plot_list[5:length(plot_list)], align = "v", nrow = 2)
```

The purpose of the data transformation for CyTOF is to separate the signal from the noise, and from a visual perspective to make the data "gateable." This means we want it to be as similar to transformed flow cytometry data as possible (the best practices for this type of data). See figure 1 in [Bendall, Simonds, et al (2011)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3273988/). Please note the co-first authorship. Many refer to this paper as Bendall et al, 2011, but Erin Simonds contributed equally. 

We note here that in terms of the "scale-argument" that there is not much of a difference between, for example, 5 and 10. We do see a difference when you don't have a scale argument at all, or when you set the scale argument very high, in which the data start to take the shape of the untransformed value. 

## Asinh vs log transformation

Now since the paper has been written single-cell sequencing has taken off, largely a result of [Macosko et al, 2015](https://www.cell.com/fulltext/S0092-8674(15)00549-8) also known as the drop-seq paper. A common analysis pipeline for these data is [Seurat from the laboratory of Rahul Satija](https://satijalab.org/seurat/). Here, the data transformation is the natural log of the data plus 1 (in R, this is log1p). Let's see what this does to the CyTOF data. 

```{r asinh_vs_log}
p1 <- MakePlot(biaxial) + ggtitle("untransformed")
p2 <- MakePlot(asinh(biaxial/5)) + ggtitle("asinh(x/5)")
p3 <- MakePlot(log1p(biaxial)) + ggtitle("log(x + 1)")
p4 <- MakePlot(log(biaxial)) + ggtitle("log(x)")
cowplot::plot_grid(plotlist = list(p1, p2, p3, p4), align = "v", nrow = 2)
```

We can see that the log(x + 1) does not look much different than the asinh with a scale argument of 5. Regardless of rationale, this shows that slightly changing the data transformation does not make or break the data. We see that the log(x) transform does produce data that are problematic, in that there is a large gap between the lowest possible value of the cell and the second lowest possible value of the cell. In flow cytometry, there are many data transformations that get the job done. It's probably the same for CyTOF, despite the fact that asinh(x/5) is universal.

## Relationship between asinh and log transformations

We can make this a bit more concrete by subtracting the matricies from each other and seeing what the differences are. 

```{r transform_diffs}
b_asinh <- asinh(biaxial/5)
b_log1p <- log1p(biaxial)

p1 <- qplot(biaxial$`166Er_CD33`, b_asinh$`166Er_CD33`) + ggtitle("untransformed vs asinh(x/5)")
p2 <- qplot(biaxial$`166Er_CD33`, b_log1p$`166Er_CD33`) + ggtitle("untransformed vs log(x + 1)")
p3 <- qplot(b_asinh$`166Er_CD33`, b_log1p$`166Er_CD33`) + ggtitle("asinh(x/5) vs log(x + 1)")

cowplot::plot_grid(plotlist = list(p1, p2, p3), align = "v", nrow = 2)
```

In the first two cases, correlating the original data with the transformed data, the transformed data decrease more rapidly as the untransformed values near zero. This is to say that the transformed data are more sensitive to changes in values near zero. 

We can see that asinh and log1p are largely correlated, but there is subtle version of the trend that is similar to what we saw between the untransformed data and the transformed data. That is that log1p decreases more rapidly than asinh as the line approaches zero. This is to say that in the values very close to zero, log1p is just a bit more sensitive than the asinh. However, for the sake of CyTOF data, when the values are near this close to zero, we typically consider this as the "negative" population. You can see this in the biaxial plots. Furthermore (this is anecdotal from a conversation with Sean Bendall, mass spec chemist by training, in 2012 or so) the variance of the values near zero in terms of the ions hitting the detector for CyTOF data are meaningless for all practical purposes. Thus, the asinh does a good job "squishing" the values near zero as opposed to a log transforation. I show here that yes this is true, but it's more subtle than I appreciated.  

But let's do one more comparison. Does the asinh by itself "squash" the values near zero? Or is it the scale argument?

```{r scale_arg_diffs}
b_asinh <- asinh(biaxial)
b_asinh5 <- asinh(biaxial/5)
b_log1p <- log1p(biaxial)
b_log1p5 <- log1p(biaxial/5)

p1 <- qplot(b_asinh$`166Er_CD33`, b_log1p$`166Er_CD33`) + ggtitle("asinh(x) vs log(x + 1)")
p2 <- qplot(b_asinh5$`166Er_CD33`, b_log1p$`166Er_CD33`) + ggtitle("asinh(x/5) vs log(x + 1)")
p3 <- qplot(b_log1p5$`166Er_CD33`, b_asinh$`166Er_CD33`) + ggtitle("log((x + 1)/5) vs asinh(x)")
p4 <- qplot(b_asinh5$`166Er_CD33`, b_log1p5$`166Er_CD33`) + ggtitle("asinh(x/5) vs log((x + 1)/5)")

cowplot::plot_grid(plotlist = list(p1, p2, p3, p4), align = "v", nrow = 2)
```

What we find is it's the scale argument that brings the values closer to zero, not log vs asinh, per-se. However, what we see is that in the asinh case, we see the influence of the scale argument at lower values than the log case. In other words, we see the "curve" in the plots start at lower values in the asinh case as opposed to the log case. 

If a goal of the data transformation and scale argument is to bring values that are near zero closer to zero, then you would choose the asinh transformation over the log transformation if you want this to happen at values closer to zero than the log transformation can provide. 

## t-SNE and data transformation

Now we've seen that the data transformations do matter in terms of how a user interprets how the cells should be subsetted. Now we will see if data transformation matters in terms of dimension reduction. We'll focus on t-SNE for now. Below, we run t-SNE on untransformed data and transformed data, and visually examine the output of both. 

```{r tsne}
library(Rtsne)

cells <- cells[grep("CD", names(cells))]

tsne_orig <- Rtsne::Rtsne(cells, check_duplicates = FALSE)$Y %>% as_tibble()
tsne_asinh <- Rtsne::Rtsne(asinh(cells/5), check_duplicates = FALSE)$Y %>% as_tibble()
tsne_log1p <- Rtsne::Rtsne(log1p(cells), check_duplicates = FALSE)$Y %>% as_tibble()

qplot(tsne_orig[[1]], tsne_orig[[2]], color = cells$`150Nd_CD3`)
qplot(tsne_asinh[[1]], tsne_asinh[[2]],  color = asinh(cells$`150Nd_CD3`/5))
qplot(tsne_log1p[[1]], tsne_log1p[[2]],  color = log1p(cells$`150Nd_CD3`))
```

One observation is that the t-SNE map for the untransformed data looks different but it doesn't look like complete chaos (eg. a ball). There appear to be different subsets that are discerned by the algorithm despite the fact that the data are untransformed. 

This being said, it looks much more like a continuum than a series of nicely subsetted niches. We color by CD3 to show that there are many more visible "subsets" when the data are transformed, both from asinh(x/5) and log1p(x). One can see that these transformations can change the interpretation of our data. Data transformation leads to a better color palette as well. 


